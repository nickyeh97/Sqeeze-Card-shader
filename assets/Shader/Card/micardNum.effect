// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.  


CCEffect %{
  techniques:
  - passes:
    - vert: vs
      frag: fs
      blendState:
        targets:
        - blend: true
      rasterizerState:
        cullMode: none
      properties:
        texture: { value: white }
        sprWidth: { value: 100 }
        sprHight: { value: 100 }
        worldSprWidth: { value: 100 }
        worldSprHeight: { value: 100 }
        disX: { value: [0, 0] }
        disY: { value: [0, 0] }
        xlist: { value: [0, 0, 0, 0] }
        ylist: { value: [0, 0, 0, 0] }
        worldPos: { value: [0, 0] }
        disXSymmetricPos: { value: [0, 0] }
        disYSymmetricPos: { value: [0, 0] }
        xlistSymmetricPos: { value: [0, 0, 0, 0] }
        ylistSymmetricPos: { value: [0, 0, 0, 0] }
}%

CCProgram vs %{
  precision highp float; 

  #include <cc-global>   // 需要显式的包含内置变量声明文件,如cc_matViewProj 等内置对象.
  #include <cc-local>

  in vec3 a_position; // 相当于旧版的attribute 声明, 用于从渲染管线中获取当前属性信息.
  in vec4 a_color;
  out vec4 v_color; // 相当于旧版的 varying 声明, 用于向下一个渲染管道传递数据.

  #if USE_TEXTURE
  in vec2 a_uv0;
  out vec2 v_uv0;
  #endif

  uniform PROPERTIES{
    float sprWidth;
    float sprHight;
    float worldSprWidth;
    float worldSprHeight;
    vec2 disX;
    vec2 disY;
    vec2 disYSymmetricPos;
    vec2 disXSymmetricPos;
    vec2 worldPos;
    vec2 _padding;
    vec4 xlist;
    vec4 ylist;
    vec4 xlistSymmetricPos;
    vec4 ylistSymmetricPos;
    
  }; 

  out highp float v_sprWidth;
  out highp float v_sprHight;
  out highp vec4 v_xlist;
  out highp vec4 v_ylist;
  out highp vec2 v_disX;
  out highp vec2 v_disY;

  vec2 getSymmetricPos(vec2 sp,vec2 pos1, vec2 pos2)
  {
    float disX = pos2.x - pos1.x;
    float disY = pos2.y - pos1.y;
    if (disX == 0.0)
    {
        float x = pos1.x - sp.x;
        return vec2(pos1.x + x,sp.y);
    }
    //获取截线斜率
    float m = disY/disX;

    //设对称点坐标(x,y)
    //直线方程式
    //y = k(x-x1) + y1
    //方程式
    //(y - sp.y)/(x - sp.x) = -1/m; 方程式(1)
    //(y+sp.y)/2 = m*((x + sp.x)/2 - pos1.x) + pos1.y;方程式(2)

    //由方程式(1)得
    //x = (y - sp.y)/(-1/m)+sp.x
    //x = sp.y*m - y*m + sp.x
    //由方程式(2)得
    //y = m*x + m*sp.x - m*pos1.x*2 + pos1.y*2 - sp.y;
    //方程式(1)带入(2)得
    //y = m*( sp.y*m - y*m + sp.x ) + m*sp.x - m*pos1.x*2 + pos1.y*2 - sp.y;
    //y = sp.y*m*m - y*m*m + sp.x*m + m*sp.x - m*pos1.x*2 + pos1.y*2 - sp.y;

    float y = (sp.y*m*m  + sp.x*m + m*sp.x - m*pos1.x*2.0 + pos1.y*2.0 - sp.y)/(1.0+m*m);
    float x = (y - sp.y)/(-1.0/m)+sp.x;

    return vec2(x,y);
  }

  
  void main () {
    v_sprWidth = sprWidth;
    v_sprHight = sprHight;
    v_xlist = xlist; 
    v_ylist = ylist;
    v_disX = disX;
    v_disY = disY;

    vec2 pos1 = vec2(0.0,0.0);
    vec2 pos2 = vec2(0.0,0.0);

    if (disXSymmetricPos[0] != 0.0 || disXSymmetricPos[1] != 0.0)
    {
      if (disXSymmetricPos[0] == 0.0)
      {
          pos1 = vec2(disXSymmetricPos[1] + worldPos.x,worldPos.y);
          pos2 = vec2(disXSymmetricPos[1] + worldPos.x,worldPos.y+worldSprHeight);
      }
      else
      {
          pos1 = vec2(disXSymmetricPos[0] + worldPos.x,worldPos.y);
          pos2 = vec2(disXSymmetricPos[0] + worldPos.x,worldPos.y+worldSprHeight);
      }
    }
    else if (disYSymmetricPos[0] != 0.0 || disYSymmetricPos[1] != 0.0)
    {
      if (disYSymmetricPos[0] == 0.0)
      {
          pos1 = vec2(worldPos.x,(worldSprHeight - disYSymmetricPos[1]) + worldPos.y);
          pos2 = vec2(worldPos.x + worldSprWidth, (worldSprHeight - disYSymmetricPos[1]) + worldPos.y);
      }
      else
      {
          pos1 = vec2(worldPos.x, (worldSprHeight - disYSymmetricPos[0]) + worldPos.y);
          pos2 = vec2(worldPos.x + worldSprWidth, (worldSprHeight - disYSymmetricPos[0]) + worldPos.y);
      }
    }
    else if(xlistSymmetricPos.x != 0.0 || xlistSymmetricPos.y != 0.0 || xlistSymmetricPos.z != 0.0){
      pos1 = vec2(xlistSymmetricPos.y+worldPos.x,worldSprHeight - ylistSymmetricPos.y + worldPos.y);
      pos2 = vec2(xlistSymmetricPos.z+worldPos.x,worldSprHeight - ylistSymmetricPos.z + worldPos.y);
    }

    vec2 sp = vec2(a_position.x, a_position.y);
    vec2 symmetricPos = getSymmetricPos(sp,pos1,pos2);
    vec4 tmp_pos = vec4(a_position.x, a_position.y,a_position.z, 1.0);
    tmp_pos.x = symmetricPos.x ;
    tmp_pos.y = symmetricPos.y ;
    
    mat4 mvp = cc_matViewProj;
    v_uv0 = a_uv0;
    v_color = a_color;

    gl_Position = mvp * tmp_pos;
    
  }
}%

CCProgram fs %{
  precision highp float;
  
  #include <alpha-test>

  in vec4 v_color;

  #if USE_TEXTURE
  in vec2 v_uv0;
  uniform sampler2D texture;
  #endif

  varying float v_sprWidth;
  varying float v_sprHight;
  varying highp vec4 v_xlist;
  varying highp vec4 v_ylist;
  varying highp vec2 v_disX;
  varying highp vec2 v_disY;

  bool isHide(float px , float py)
  {
    bool b = false;
    float dx = px * v_sprWidth;
    float dy = py * v_sprHight;
    if (v_disX[0] != 0.0 || v_disX[1] != 0.0)
    {
        if (dx >= v_disX[0] && dx <= v_disX[1]){
            return true;
        }
    }
    else if (v_disY[0] != 0.0 || v_disY[1] != 0.0)
    {
        if (dy >= v_disY[0] && dy <= v_disY[1]){
            return true;
        }
    }
    
    if ( ((v_ylist[0]>=dy) != (v_ylist[2]>=dy)) && (dx < (v_xlist[2]-v_xlist[0]) * (dy-v_ylist[0]) / (v_ylist[2]-v_ylist[0]) + v_xlist[0]) )
    {
      b = !b;
    }
    if ( ((v_ylist[1]>=dy) != (v_ylist[0]>=dy)) && (dx < (v_xlist[0]-v_xlist[1]) * (dy-v_ylist[1]) / (v_ylist[0]-v_ylist[1]) + v_xlist[1]) )
    {
      b = !b;
    }
    if ( ((v_ylist[2]>=dy) != (v_ylist[1]>=dy)) && (dx < (v_xlist[1]-v_xlist[2]) * (dy-v_ylist[2]) / (v_ylist[1]-v_ylist[2]) + v_xlist[2]) )
    {
      b = !b;
    }

    return b;
  }

  void main () {
    vec4 color = texture2D(texture, v_uv0);
    bool hide = isHide(v_uv0.x,v_uv0.y);
    // if test mode color.a = 0.5 , will understand how the card textture rendering in fs.
    if (!hide)
    {
        color.a = 0.0;
    }

    gl_FragColor = v_color*color;
  }

}%
