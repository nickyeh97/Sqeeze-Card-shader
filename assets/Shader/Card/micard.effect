// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.  

// https://docs.cocos.com/creator3d/manual/zh/material-system/effect-syntax.html
// https://forum.cocos.org/t/cocos-2-3-shader/90789
// 格式说明:
//   CCEffect %{}% 中 编写techniques 相关声明, 与旧版相比, 采用了yaml 编写格式, 而旧版则用json格式.
//   yaml 标准格式目前已有很多地方可见其身影,如 springboot 项目中的配置文件. 优点是语法精简, 且能够包含继承关系等配置.
//   CCProgram 则用来声明渲染管线的代码片断, 其中需要包含代码片断的入口函数void main() 与旧版基本没有太大差别,其中变量传递废弃了标准glsl 语法中的 attribute/ varying 限定符, 而统一改用 in/out/ inout 关键字.

CCEffect %{
  techniques:
  - passes:
    - vert: vs
      frag: fs
      blendState:
        targets:
        - blend: true
      rasterizerState:
        cullMode: none
      properties:
        texture: { value: white }
        sprWidth: { value: 100 }
        sprHight: { value: 100 }
        disX: { value: [0, 0] }   
        disY: { value: [0, 0] } 
        xlist: { value: [0, 0, 0, 0] } 
        ylist: { value: [0, 0, 0, 0] }
}%

CCProgram vs %{
  precision highp float; 

  #include <cc-global>   // 需要显式的包含内置变量声明文件,如cc_matViewProj 等内置对象.
  #include <cc-local>

  in vec3 a_position; // 相当于旧版的attribute 声明, 用于从渲染管线中获取当前属性信息.
  in vec4 a_color;
  out vec4 v_color; // 相当于旧版的 varying 声明, 用于向下一个渲染管道传递数据.

  #if USE_TEXTURE
  in vec2 a_uv0;
  out vec2 v_uv0;
  #endif

  uniform PROPERTIES{
    float sprWidth;
    float sprHight;
    vec2 disX;
    vec2 disY;
    vec2 _padding;
    vec4 xlist;
    vec4 ylist;
  }; 

  out highp float v_sprWidth;
  out highp float v_sprHight;
  out highp vec4 v_xlist;
  out highp vec4 v_ylist;
  out highp vec2 v_disX;
  out highp vec2 v_disY;

  void main () {
    vec4 pos = vec4(a_position, 1);

    #if CC_USE_MODEL
    pos = cc_matViewProj * cc_matWorld * pos;
    #else
    pos = cc_matViewProj * pos;
    #endif

    #if USE_TEXTURE
    v_uv0 = a_uv0;
    #endif

    v_sprWidth = sprWidth;
    v_sprHight = sprHight; 
    v_xlist = xlist; 
    v_ylist = ylist;
    v_disX = disX;
    v_disY = disY;

    v_color = a_color;
    
    gl_Position = pos;
  }
}%

CCProgram fs %{
  precision highp float;
  
  #include <alpha-test>

  in vec4 v_color;

  #if USE_TEXTURE
  in vec2 v_uv0;
  uniform sampler2D texture;
  #endif

  varying highp float v_sprWidth;
  varying highp float v_sprHight;
  varying highp vec4 v_xlist;
  varying highp vec4 v_ylist;
  varying highp vec2 v_disX;
  varying highp vec2 v_disY;

  bool isHide(float px , float py)
  {
    bool b = false;
    float dx = px * v_sprWidth;
    float dy = py * v_sprHight;
    if (v_disX[0] != 0.0 || v_disX[1] != 0.0)
    {
        if (dx >= v_disX[0] && dx <= v_disX[1]){
            return true;
        }
    }
    else if (v_disY[0] != 0.0 || v_disY[1] != 0.0)
    {
        if (dy >= v_disY[0] && dy <= v_disY[1]){
            return true;
        }
    }
    
    if ( ((v_ylist[0]>=dy) != (v_ylist[2]>=dy)) && (dx < (v_xlist[2]-v_xlist[0]) * (dy-v_ylist[0]) / (v_ylist[2]-v_ylist[0]) + v_xlist[0]) )
    {
      b = !b;
    }
    if ( ((v_ylist[1]>=dy) != (v_ylist[0]>=dy)) && (dx < (v_xlist[0]-v_xlist[1]) * (dy-v_ylist[1]) / (v_ylist[0]-v_ylist[1]) + v_xlist[1]) )
    {
      b = !b;
    }
    if ( ((v_ylist[2]>=dy) != (v_ylist[1]>=dy)) && (dx < (v_xlist[1]-v_xlist[2]) * (dy-v_ylist[2]) / (v_ylist[1]-v_ylist[2]) + v_xlist[2]) )
    {
      b = !b;
    }

    return b;
  }

  void main () {
    vec4 color = texture2D(texture, v_uv0);
    bool hide = isHide(v_uv0.x,v_uv0.y);
    if (hide)
    {
      color.a = 0.0;
    }
    gl_FragColor = color;
  }

}%
